<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Curtis Matrix Clock (Embedded)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: monospace;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="matrix"></canvas>

<script>
// ========== TIME (5-MIN ROUND, 12-HOUR + AM/PM) ==========
function pad(n) { return n < 10 ? "0" + n : "" + n; }

function getRoundedTimestamp() {
  const now = new Date();

  const rounded = new Date(now);
  rounded.setMinutes(Math.floor(now.getMinutes() / 5) * 5, 0, 0);

  let h = rounded.getHours();
  const ampm = h >= 12 ? "PM" : "AM";
  h = h % 12;
  if (h === 0) h = 12;

  const hh = pad(h);
  const mm = pad(rounded.getMinutes());
  const timeStr = `${hh}:${mm} ${ampm}`;

  const dateStr = rounded.toLocaleDateString(undefined, {
    weekday: "short",
    month: "short",
    day: "numeric"
  });

  return { timeStr, dateStr };
}

const { timeStr, dateStr } = getRoundedTimestamp();

// =================== MATRIX SETUP ===================
const canvas = document.getElementById("matrix");
const ctx = canvas.getContext("2d");

let fontSize = 12;
let cols = 0;
let maxRows = 0;
let drops = [];
let embeds = [];

const chars =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{};:<>,.?/";

// compute layout for current size (works for 800x480 + previews)
function initCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // smaller font -> more columns (dense rain)
  fontSize = Math.floor(canvas.width / 64); // ≈64 cols at 800px
  if (fontSize < 10) fontSize = 10;
  if (fontSize > 14) fontSize = 14;

  ctx.font = fontSize + "px monospace";

  cols = Math.floor(canvas.width / fontSize);
  maxRows = Math.floor(canvas.height / fontSize);

  // drops start above screen to build vertical trails
  drops = Array(cols)
    .fill(0)
    .map(() => Math.floor(Math.random() * -maxRows));

  computeEmbeds();
}

// build list of embedded characters (time + date)
// each with a column & row position
function computeEmbeds() {
  const centerCol = Math.floor(cols / 2);
  const centerRow = Math.floor(maxRows / 2);

  const timeRow = centerRow - 1;
  const dateRow = centerRow + 1;

  const timeStart = centerCol - Math.floor(timeStr.length / 2);
  const dateStart = centerCol - Math.floor(dateStr.length / 2);

  embeds = [];

  for (let i = 0; i < timeStr.length; i++) {
    embeds.push({
      col: timeStart + i,
      row: timeRow,
      ch: timeStr.charAt(i)
    });
  }

  for (let i = 0; i < dateStr.length; i++) {
    embeds.push({
      col: dateStart + i,
      row: dateRow,
      ch: dateStr.charAt(i)
    });
  }
}

initCanvas();
window.addEventListener("resize", initCanvas);

// quick lookup: for any column, do we have an embedded char there?
function embedForColumn(col) {
  // there may be multiple (time + date) in same col, but that’s fine
  return embeds.filter(e => e.col === col);
}

// =================== DRAW FRAME ===================
function drawFrame() {
  // very light fade -> strong ghost trails (TRMNL look)
  ctx.fillStyle = "rgba(0, 0, 0, 0.06)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.font = fontSize + "px monospace";

  // first, advance drops & draw normal rain
  ctx.fillStyle = "rgba(255,255,255,0.70)";

  for (let col = 0; col < cols; col++) {
    const x = col * fontSize;
    const y = drops[col] * fontSize;

    const char = chars.charAt(Math.floor(Math.random() * chars.length));
    ctx.fillText(char, x, y);

    drops[col]++;

    if (drops[col] * fontSize > canvas.height && Math.random() > 0.975) {
      drops[col] = Math.floor(Math.random() * -maxRows);
    }
  }

  // now "embed" the time/date inside those same columns:
  // force the drop position for those columns to the desired row,
  // and draw a bold, bright glyph at that exact grid cell.
  ctx.font = "bold " + fontSize + "px monospace";
  ctx.fillStyle = "rgba(255,255,255,1)";

  embeds.forEach(e => {
    // ensure the rain in this column is at the embed row
    drops[e.col] = e.row;

    const x = e.col * fontSize;
    const y = e.row * fontSize;
    ctx.fillText(e.ch, x, y);
  });
}

// warm up a bunch of frames so the first snapshot is nicely dense
function warmup(frames) {
  for (let i = 0; i < frames; i++) {
    drawFrame();
  }
}

warmup(Math.floor(maxRows * 1.5));
setInterval(drawFrame, 180);
</script>
</body>
</html>
